# Индивидуальная работа номер 2

Из лабораторной работы возьмите текстовый файл с данными и определения структур данных.

Требуется реализовать программу на любом удобном вам языке программирования, в которой реализовано __3 способа сортировки__ массивов данных из созданного файла по ключу. 
Для каждого метода сортировки проанализировать теоретическую и практическую сложности.

## Для каждого алгоритма вывести следующую информацию:

* теоретичекая оценка сложности
* количество сравнений
* количество перестановок
* время выполнения алгоритма

## Методы сортировки

### 1. __Bubble Sort__
<div id="header" align="center">
  <img src="https://i.stack.imgur.com/XNbE0.gif" width="300"/>
</div>
Принцип действий прост: 
обходим массив от начала до конца, 
попутно меняя местами неотсортированные соседние элементы. 
В результате первого прохода на последнее место «всплывёт» максимальный элемент. 
Теперь снова обходим неотсортированную часть массива (от первого элемента до предпоследнего) и 
меняем по пути неотсортированных соседей. Второй по величине элемент окажется на предпоследнем месте. 
Продолжая в том же духе, будем обходить всё уменьшающуюся неотсортированную часть массива, 
запихивая найденные максимумы в конец.

#### Сложность
|             <center>Значение | Временная сложность</center> |
|-----------------------------:|------------------------------|
|         <center>Лучшее время | <center>*O(n)*</center>      |
|         <center>Худшее время | <center>*O(n<sup>2</sup>)*           |
|        <center>Среднее время | <center>*O(n<sup>2</sup>)*           |
|       <center>Затраты памяти | <center>*O(1)*                       |

### 1. __Selection Sort__
<div id="header" align="center">
  <img src="https://miro.medium.com/v2/resize:fit:828/1*5WXRN62ddiM_Gcf4GDdCZg.gif" width="300"/>
</div>
Итак, идея сортировок выбором состоит в следующем: 

1. В неотсортированном подмассиве ищется локальный максимум (минимум). 
2. Найденный максимум (минимум) меняется местами с последним (первым) элементом в подмассиве. 
3. Если в массиве остались неотсортированные подмассивы — возвращаемся к пункту 1.

В моем случае, выбран минимальный элемент. То есть, проходим по массиву в поисках минимального элемента. 
Найденный минимум меняем местами с первым элементом. Неотсортированная часть массива уменьшилась на один элемент 
(не включает первый элемент, куда мы переставили найденный минимум). 
К этой неотсортированной части применяем те же действия — находим минимум и ставим его на первое место в неотсортированной части массива. 
И так продолжаем до тех пор, пока неотсортированная часть массива не уменьшится до одного элемента.

#### Сложность
|             <center>Значение | Временная сложность</center>               |
|-----------------------------:|--------------------------------------------|
|         <center>Лучшее время | <center>*O(n<sup>2</sup>)*</center>        |
|         <center>Худшее время | <center>*O(n<sup>2</sup>)*                 |
|        <center>Среднее время | <center>*O(n<sup>2</sup>)*                 |
|       <center>Затраты памяти | <center>*O(n)* всего, *O(1)* дополнительно |

### 1. __Shell Sort__
<div id="header" align="center">
  <img src="https://upload.wikimedia.org/wikipedia/commons/6/61/Sorting_shellsort_anim2.gif" width="300"/>
</div>
Shell Sort — это тот же самый Insertion Sort, но перед сортировкой с помощью Insertion Sort, 
мы проводим “грубый” проход. Грубый проход — это сравнение элементов, которые находяться на расстоянии 
gap. 

Итак, идея метода заключается в сравнение разделенных на группы элементов последовательности, 
находящихся друг от друга на некотором расстоянии. Изначально это расстояние равно gap или N/2, 
где N — общее число элементов. 
На первом шаге каждая группа включает в себя два элемента расположенных друг от друга на расстоянии 
N/2; они сравниваются между собой, и, в случае необходимости, меняются местами. 
На последующих шагах также происходят проверка и обмен, но расстояние gap сокращается на gap/2, 
и количество групп, соответственно, уменьшается. Постепенно расстояние между элементами уменьшается,
и на gap=1 проход по массиву происходит в последний раз.


#### Сложность
|             <center>Значение | Временная сложность</center>               |
|-----------------------------:|--------------------------------------------|
|         <center>Лучшее время | <center>*O(nlog<sup>2</sup>n)*</center>    |
|         <center>Худшее время | <center>*O(n<sup>2</sup>)*                 |
|        <center>Среднее время | <center>Зависит от выбранных шагов         |
|       <center>Затраты памяти | <center>*O(n)* всего, *O(1)* дополнительно |